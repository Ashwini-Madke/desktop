enum MergeResultKind {
  Success = 'Success',
  Failure = 'Failure',
}

interface IBlobResult {
  readonly mode: string
  readonly sha: string
}

interface IMergeEntry {
  readonly path: string
  readonly result: IBlobResult
  readonly our?: IBlobResult
  readonly their?: IBlobResult
  readonly diff: string
}

export interface IMergeSuccess {
  readonly kind: MergeResultKind.Success
  readonly entries: ReadonlyArray<IMergeEntry>
}

interface IMergeError {
  readonly kind: MergeResultKind.Failure
  readonly conflictedFiles: number
}

type MergeResult = IMergeSuccess | IMergeError

// examples:
//  result 100644 2f9cf6d58beb7abf74b241c52c4deed1155c7e98 app/src/lib/app-state.ts
//  our    100644 5382e869682845ac92aee17c4ebcb0609749ab88 app/src/lib/app-state.ts
const fileEntryRegex = /^\s{2}(result|our)\s+(\d{6})\s([0-9a-f]{40})\s(.+)$$/

export class MergeParser {
  /**
   * Line start pointer.
   *
   * The offset into the text property where the current line starts (ie either zero
   * or one character ahead of the last newline character).
   */
  private ls!: number

  /**
   * Line end pointer.
   *
   * The offset into the text property where the current line ends (ie it points to
   * the newline character) or -1 if the line boundary hasn't been determined yet
   */
  private le!: number

  /**
   * The text buffer containing the raw, unified merge output to be parsed
   */
  private text!: string

  public constructor() {
    this.reset()
  }

  /**
   * Resets the internal parser state so that it can be reused.
   *
   * This is done automatically at the end of each parse run.
   */
  private reset() {
    this.ls = 0
    this.le = -1
    this.text = ''
  }

  public parse(text: string): MergeResult {
    this.text = text

    const entries = new Array<IMergeEntry>()

    const lines = this.text.split('\n')

    let line: string | undefined
    let currentMergeEntry: IMergeEntry | undefined

    while ((line = lines.shift())) {
      // this is the header for each entry
      if (line.startsWith('merged')) {
        // push the previous entry, if defined, into the array
        if (currentMergeEntry != null) {
          entries.push(currentMergeEntry)
          currentMergeEntry = undefined
        }

        continue
      }

      // the next lines are a number of merge result entries
      // pointing to blobs representing the source blob
      // and the resulting blob generated by the merge
      const match = fileEntryRegex.exec(line)
      if (match != null && match.length === 5) {
        const type = match[1]
        const mode = match[2]
        const sha = match[3]
        const path = match[4]

        switch (type) {
          case 'result':
            // create a new entry
            currentMergeEntry = {
              path,
              result: {
                sha,
                mode,
              },
              diff: '',
            }

            break

          case 'our':
            if (currentMergeEntry == null) {
              console.log(
                'invalid state - `our` should never be seen before we get a `result` entry'
              )
              break
            }

            // add 'our' to the current merge entry
            currentMergeEntry = {
              ...currentMergeEntry,
              our: {
                sha,
                mode,
              },
            }

            break

          default:
            console.log(
              `invalid state - unexpected entry ${type} found when parsing rows`
            )
        }
      }

      if (currentMergeEntry == null) {
        console.log(
          `invalid state - trying to append the diff to a merge entry that isn't defined`
        )
      } else {
        const currentDiff = currentMergeEntry.diff
        const newDiff = currentDiff + line
        currentMergeEntry = {
          ...currentMergeEntry,
          diff: newDiff,
        }
      }
    }

    // ensure the last entry is pushed onto the array

    if (currentMergeEntry != null) {
      entries.push(currentMergeEntry)
    }

    return { kind: MergeResultKind.Success, entries }
  }
}
